<?php

/**
 * @file
 * Views Tree module.
 */

use Drupal\views\Plugin\views\field\FieldPluginBase;

/**
 * Implements hook_theme().
 */
function views_tree_theme($existing, $type, $theme, $path) {
  // @todo use templates.
  return array(
    'views_tree' => array(
      'variables' => array(
        'view' => NULL,
        'options' => array(),
        'rows' => array(),
        'title' => NULL,
      ),
      'function' => 'theme_views_tree',
    ),
    'views_tree_inner' => array(
      'variables' => array(
        'view' => NULL,
        'options' => array(),
        'rows' => array(),
        'title' => NULL,
        'result' => array(),
        'parent' => NULL,
      ),
      'function' => 'theme_views_tree_inner',
    ),
  );
}

function template_preprocess_views_tree(&$vars) {
  /** @var \Drupal\views\ViewExecutable $view */
  $view = $vars['view'];
  $options = $view->getStyle()->options;
  $vars['#attached']['library'][] = 'views_tree/views_tree';

  // Add JS and CSS for collapsible tree, if configured.
  if (!empty($options['collapsible_tree'])) {
    $vars['#attached']['drupalSettings'] = [
      'views_tree_settings' => [[
        $view->id(),
        $options['collapsible_tree'],
      ],
    ]];
  }
}


/**
 * Theme function for the tree style plugin.
 *
 * We need to do some weirdness that makes more sense as a theme function than
 * as a template.
 *
 * @ingroup themeable
 * @link http://drupal.org/node/355919
 */
function theme_views_tree($variables) {
  /** @var \Drupal\views\ViewExecutable $view */
  $view = $variables['view'];
  $options = $view->getStyle()->options;
  $rows = $variables['rows'];
  $title = $variables['title'];

  $result = $view->result;
  $fields = &$view->field;

  $parents = array();

  if (! $fields[$options['main_field']] instanceof FieldPluginBase) {
    drupal_set_message(t('Main field is invalid: %field', array('%field' => $options['main_field'])), 'error');
    return '';
  }

  if (! $fields[$options['parent_field']] instanceof FieldPluginBase) {
    drupal_set_message(t('Parent field is invalid: %field', array('%field' => $options['parent_field'])), 'error');
    return '';
  }

  // The field structure of Field API fields in a views result object is...
  // ridiculous. To avoid having to deal with it, we'll first iterate over all
  // records and normalize out the main and parent IDs to new properties. That
  // vastly simplifies the code that follows. This particular magic incantation
  // extracts the value from each record for the appropriate field specified by
  // the user. It then normalizes that value down to just an int, even though in
  // some cases it is an array. See views_tree_normalize_key(). Finally, we
  // build up a list of all main keys in the result set so that we can normalize
  // top-level records below.
  foreach ($result as $i => $record) {
    $result[$i]->views_tree_main = views_tree_normalize_key($fields[$options['main_field']]->getValue($record), $fields[$options['main_field']]);
    $result[$i]->views_tree_parent = views_tree_normalize_key($fields[$options['parent_field']]->getValue($record), $fields[$options['parent_field']]);

    $parents[] = $record->views_tree_main;
  }

  // Normalize the top level of records to all point to 0 as their parent
  // We only have to do this once, so we do it here in the wrapping function.
  foreach ($result as $i => $record) {
    if (! in_array($record->views_tree_parent, $parents)) {
      $result[$i]->views_tree_parent = 0;
    }
  }

  // Recursively render each item.
  $build = [
    '#theme' => 'views_tree_inner',
    '#view' => $view,
    '#options' => $options,
    '#rows' => $rows,
    '#title' => $title,
    '#result' => $result,
    '#parent' => 0,
  ];
  $tree = \Drupal::service('renderer')->render($build);

  return $title . $tree;
}

/**
 * Inner recursive theme function for views tree theming.
 *
 * @ingroup themeable
 * @param $view
 * @param $options
 * @param $row
 * @param $title
 * @param $result
 *   An array representing the raw data returned from the query.
 * @param $parent
 *   The id of the parent entry in the call stack.
 */
function theme_views_tree_inner($variables) {
  $view = $variables['view'];
  $options = $variables['options'];
  $rows = $variables['rows'];
  $title = $variables['title'];
  $result = $variables['result'];
  $parent = $variables['parent'];

  $items = array();
  foreach ($result as $i => $record) {
    if ($record->views_tree_parent == $parent) {
      $variables['parent'] = $record->views_tree_main;
      $rows[$i]['#suffix'] = call_user_func(__FUNCTION__, $variables);
      $items[] = $rows[$i];
    }
  }
  $build = [
    '#theme' => 'item_list',
    '#type' => $options['type'],
    '#items' => $items,
  ];
  return count($items) ? \Drupal::service('renderer')->render($build) : '';
}

/**
 * Normalize a value out of the record to an int.
 *
 * If the field in question comes from Field API, then it will be an array, not
 * an int. We need to detect that and extract the int value we want from it.
 * Note that because Field API structures are so free-form, we have to
 * specifically support each field type.  For now we support entityreference
 * (target_id), nodereference (nid), userreference (uid), organic groups (gid),
 * and taxonomyreference (tid).
 *
 * @param mixed $value
 *   The value to normalize. It should be either an int or an array. If an int,
 *   it is returned unaltered. If it's an array, we extract the int we want and
 *   return that.
 * @param \Drupal\views\Plugin\views\field\FieldPluginBase $field
 *   Metadata about the field we are extracting information from.
 * @return int
 *   The value of this key, normalized to an int.
 */
function views_tree_normalize_key($value, FieldPluginBase $field) {
  if (is_array($value) && count($value)) {
    // @todo convert this part to Drupal 8.
    if (isset($field->field_info['columns'])) {
      $columns = array_keys($field->field_info['columns']);
      foreach ($columns as $column) {
        if (in_array($column, array('target_id', 'nid', 'uid', 'tid'))) {
          $field_property = $column;
          break;
        }
      }
    }
    else {
      $field_property = '';
    }
    return $field_property ? $value[0][$field_property] : 0;
  }
  else {
    return $value ? $value : 0;
  }
}
